

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Types, functions, and expressions &mdash; Vale: Verified Assembly Language for Everest  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Complete Vale syntax" href="grammar.html" />
    <link rel="prev" title="Programs and procedures" href="programs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Vale: Verified Assembly Language for Everest
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="programs.html">Programs and procedures</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Types, functions, and expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operands-and-operand-types">Operands and operand types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operand-constructors-and-memory">Operand constructors and memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operand-values-and-locations">Operand values and locations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-consts">Functions and consts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#custom-operators">Custom operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overloaded-operators">Overloaded operators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#expressions">Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers">Quantifiers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">Complete Vale syntax</a></li>
<li class="toctree-l1"><a class="reference internal" href="tool.html">Using the Vale tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Interface with verification framework</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vale: Verified Assembly Language for Everest</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Types, functions, and expressions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/exp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="types-functions-and-expressions">
<h1>Types, functions, and expressions<a class="headerlink" href="#types-functions-and-expressions" title="Permalink to this headline">¶</a></h1>
<p>As mentioned in <a class="reference internal" href="programs.html#programs"><span class="std std-ref">Programs and procedures</span></a>, a Vale program contains a series of top-level declarations.
These top-level declarations may be:</p>
<ul class="simple">
<li><p>type declarations and operand type declarations</p></li>
<li><p>global variable declarations</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">const</span></code> and <code class="docutils literal notranslate"><span class="pre">function</span></code> declarations</p></li>
<li><p>procedure declarations</p></li>
<li><p>verbatim blocks (see <a class="reference internal" href="grammar.html#verbatim"><span class="std std-ref">Verbatim blocks</span></a>)</p></li>
</ul>
<p>Vale processes declarations in the order they appear in the program.
The order matters,
because each declaration can refer to earlier declarations but not later declarations.
All declared names (types, variables, constants, functions, procedures)
live in a single namespace:
you cannot have a type, a function, and a procedure with the same name.
For any name <code class="docutils literal notranslate"><span class="pre">x</span></code>, there may be up one non-<code class="docutils literal notranslate"><span class="pre">extern</span></code> top-level declaration named <code class="docutils literal notranslate"><span class="pre">x</span></code>
or multiple <code class="docutils literal notranslate"><span class="pre">extern</span></code> declarations named <code class="docutils literal notranslate"><span class="pre">x</span></code>.
If two top-level <code class="docutils literal notranslate"><span class="pre">extern</span></code> declarations with the same name are declared,
the later declaration hides the earlier one.</p>
<p>For compatibility with Dafny modules and FStar modules,
names may contain <code class="docutils literal notranslate"><span class="pre">.</span></code> symbols, as in <code class="docutils literal notranslate"><span class="pre">FStar.Pervasives.option</span></code>.</p>
<p>Global variables, constants, functions, and procedures have types.
Vale has a simple type system with polymorphism but without dependent types.
Because Vale’s type system is simpler than that of some verification frameworks, such as FStar’s,
there may be expressions from the verification framework that
Vale’s type system cannot type-check.
As described in the next section, a Vale program can use type casts to access such expressions.
For formal details on Vale’s type system,
see <a class="reference external" href="https://raw.githubusercontent.com/project-everest/vale/master/doc/types.txt">here</a>.</p>
<div class="section" id="types">
<span id="id1"></span><h2>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h2>
<p>Vale has a small number of built-in types
and can import other types from the underlying verification framework.
The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">extern</span></code> declaration imports types from the verification framework:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> char:<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">type</span> option(a:<span class="k">Type</span>(<span class="m">0</span>)):<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">type</span> map(a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)):<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
</pre></div>
</div>
<p>Types can have type parameters like <code class="docutils literal notranslate"><span class="pre">a:Type(0)</span></code>.
For example, the map type shown above takes parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>,
which can be instantiated with types:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> x:map(<span class="k">int</span>, option(<span class="k">bool</span>)) := ...;
</pre></div>
</div>
<p>Every type declaration specifies a <em>kind</em> for each type parameter and a return kind.
The most common kind is <code class="docutils literal notranslate"><span class="pre">Type(0)</span></code>, and for Dafny, <code class="docutils literal notranslate"><span class="pre">Type(0)</span></code> is the only kind that is needed.
However, FStar is more complicated does not allow all types to have the same kind.
FStar’s <code class="docutils literal notranslate"><span class="pre">prop</span></code> type, for example, has kind <code class="docutils literal notranslate"><span class="pre">Type(1)</span></code>.
Therefore, Vale also supports kinds <code class="docutils literal notranslate"><span class="pre">Type(1)</span></code>, <code class="docutils literal notranslate"><span class="pre">Type(2)</span></code>, and so on.</p>
<p>Vale provides the following built-in primitive types:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code>, containing constants <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>
and used for operators like <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, and <code class="docutils literal notranslate"><span class="pre">==&gt;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">prop</span></code> (FStar only), which FStar uses instead of <code class="docutils literal notranslate"><span class="pre">bool</span></code> for <code class="docutils literal notranslate"><span class="pre">forall</span></code> and <code class="docutils literal notranslate"><span class="pre">exists</span></code>.
Vale uses the same constants <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>
and <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, and <code class="docutils literal notranslate"><span class="pre">==&gt;</span></code> for <code class="docutils literal notranslate"><span class="pre">prop</span></code> as for <code class="docutils literal notranslate"><span class="pre">bool</span></code>,
and will automatically generate the appropriate FStar operators
as necessary (e.g. generating FStar’s <code class="docutils literal notranslate"><span class="pre">/\</span></code> or <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> from Vale’s <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> as appropriate).
In Vale, <code class="docutils literal notranslate"><span class="pre">bool</span></code> is a subtype of <code class="docutils literal notranslate"><span class="pre">prop</span></code>, so values of type <code class="docutils literal notranslate"><span class="pre">bool</span></code>
can be used where a value of type <code class="docutils literal notranslate"><span class="pre">prop</span></code> is expected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span></code>, containing all mathematical integers …, (-2), (-1), 0, 1, 2, …</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int_range(I1,</span> <span class="pre">I2)</span></code>, containing integers in the range I1…I2 (including I1 and I2).
<code class="docutils literal notranslate"><span class="pre">I1</span></code> and <code class="docutils literal notranslate"><span class="pre">I2</span></code> must be integer constants or the symbol <code class="docutils literal notranslate"><span class="pre">_</span></code>,
representing no bound (i.e. negative or positive infinity).
For example, if <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">int_type(0,</span> <span class="pre">_)</span></code>,
then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> will have type <code class="docutils literal notranslate"><span class="pre">int_type(1,</span> <span class="pre">_)</span></code>.
Smaller range types are subtypes of larger range types and of <code class="docutils literal notranslate"><span class="pre">int</span></code>,
so that a value of type <code class="docutils literal notranslate"><span class="pre">int_type(1,</span> <span class="pre">_)</span></code> can be used where
a value of type <code class="docutils literal notranslate"><span class="pre">int_type(0,</span> <span class="pre">_)</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code> is expected.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tuple(t1,</span> <span class="pre">...,</span> <span class="pre">tn)</span></code> is the type of tuples containing components
of type <code class="docutils literal notranslate"><span class="pre">t1</span></code> … <code class="docutils literal notranslate"><span class="pre">tn</span></code>, created by expressions <code class="docutils literal notranslate"><span class="pre">tuple(e1,</span> <span class="pre">...,</span> <span class="pre">en)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fun(t1,</span> <span class="pre">...,</span> <span class="pre">tn)</span> <span class="pre">-&gt;</span> <span class="pre">t0</span></code> is type of functions accepting arguments
of type <code class="docutils literal notranslate"><span class="pre">t1</span></code> … <code class="docutils literal notranslate"><span class="pre">tn</span></code> and returning type <code class="docutils literal notranslate"><span class="pre">t0</span></code>.</p></li>
</ul>
<p>In addition, Vale is aware of the following types,
although they must be declared explicitly as <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">extern;</span></code> declarations
with a {:primitive} attribute (see <a class="reference internal" href="grammar.html#attributes"><span class="std std-ref">Attributes</span></a>):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">state</span></code>, the type of the program’s state (the built-in expression <code class="docutils literal notranslate"><span class="pre">this</span></code> has type <code class="docutils literal notranslate"><span class="pre">state</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">string</span></code>, the type of string literals</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">list(t)</span></code> (FStar only), the type of list literals <code class="docutils literal notranslate"><span class="pre">list(e1,</span> <span class="pre">...,</span> <span class="pre">en)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seq(t)</span></code> (Dafny only), the type of sequence literals <code class="docutils literal notranslate"><span class="pre">seq(e1,</span> <span class="pre">...,</span> <span class="pre">en)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">set(t)</span></code> (Dafny only), the type of set literals <code class="docutils literal notranslate"><span class="pre">set(e1,</span> <span class="pre">...,</span> <span class="pre">en)</span></code></p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">:=</span> <span class="pre">...;</span></code> syntax declares type abbreviations:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> my_bool:<span class="k">Type</span>(<span class="m">0</span>) := <span class="k">bool</span>;
<span class="k">type</span> nat:<span class="k">Type</span>(<span class="m">0</span>) := <span class="k">int_range</span>(<span class="m">0</span>, <span class="m">_</span>);
<span class="k">type</span> pos:<span class="k">Type</span>(<span class="m">0</span>) := <span class="k">int_range</span>(<span class="m">1</span>, <span class="m">_</span>);
<span class="k">type</span> byte:<span class="k">Type</span>(<span class="m">0</span>) := <span class="k">int_range</span>(<span class="m">0</span>, <span class="m">0xff</span>);
<span class="k">type</span> int_map(a:<span class="k">Type</span>(<span class="m">0</span>)):<span class="k">Type</span>(<span class="m">0</span>) := map(<span class="k">int</span>, a);
</pre></div>
</div>
<p>Within Vale’s type system, type abbreviations like <code class="docutils literal notranslate"><span class="pre">nat</span></code> are equivalent to the types
that they abbreviate, like <code class="docutils literal notranslate"><span class="pre">int_range(0,</span> <span class="pre">_)</span></code>.
When generating Dafny/FStar code, Vale attempts to preserve abbreviations,
so that if variable <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">nat</span></code> in the Vale code,
it will have type <code class="docutils literal notranslate"><span class="pre">nat</span></code> in the Dafny or FStar code, not <code class="docutils literal notranslate"><span class="pre">int_range(0,</span> <span class="pre">_)</span></code>.
Vale will not generate a declaration of the <code class="docutils literal notranslate"><span class="pre">nat</span></code> type itself,
so <code class="docutils literal notranslate"><span class="pre">nat</span></code> must be declared manually in separate Dafny or FStar code.
Also note that raw <code class="docutils literal notranslate"><span class="pre">int_range</span></code> types do not have built-in equivalents in Dafny and FStar:
<code class="docutils literal notranslate"><span class="pre">int_range</span></code> is translated into <code class="docutils literal notranslate"><span class="pre">int</span></code> in Dafny and into refinements of <code class="docutils literal notranslate"><span class="pre">int</span></code> in FStar.</p>
<p><code class="docutils literal notranslate"><span class="pre">extern</span></code> procedures and functions can be polymorphic over types:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">ghost</span> <span class="k">procedure</span> g<span class="m">1</span>#[a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)](<span class="k">ghost</span> x:a, <span class="k">ghost</span> y:b)
    <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> g<span class="m">2</span>()
{
    g<span class="m">1</span>(<span class="m">10</span>, <span class="k">true</span>);
    g<span class="m">1</span>#[<span class="k">int</span>, <span class="k">bool</span>](<span class="m">10</span>, <span class="k">true</span>);
}
</pre></div>
</div>
<p>The explicit type arguments <code class="docutils literal notranslate"><span class="pre">#[int,</span> <span class="pre">bool]</span></code> are optional;
without them, Vale will try to infer type arguments.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">#t(e)</span></code> or <code class="docutils literal notranslate"><span class="pre">#(t)(e)</span></code> casts expression <code class="docutils literal notranslate"><span class="pre">e</span></code> to type <code class="docutils literal notranslate"><span class="pre">t</span></code>:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">ghost</span> <span class="k">procedure</span> cast_test(<span class="k">ghost</span> i:<span class="k">int</span>)
    <span class="k">requires</span>
        i &gt;= <span class="m">0</span>;
{
    <span class="k">let</span> n:nat := #nat(i);
}
</pre></div>
</div>
<p>The cast in this example is needed because <code class="docutils literal notranslate"><span class="pre">i</span></code>’s type <code class="docutils literal notranslate"><span class="pre">int</span></code> is not a subtype of <code class="docutils literal notranslate"><span class="pre">n</span></code>’s type <code class="docutils literal notranslate"><span class="pre">nat</span></code>.</p>
<p>Although Vale does not have dependent types,
it has some limited support for interacting with some of FStar’s dependent types:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> buf_typ:<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">const</span> bt<span class="m">32</span>:buf_typ <span class="k">extern</span>;
<span class="k">const</span> bt<span class="m">64</span>:buf_typ <span class="k">extern</span>;
<span class="k">type</span> buf(bt:<span class="k">Dependent</span>(buf_typ)):<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">type</span> buf<span class="m">32</span>:<span class="k">Type</span>(<span class="m">0</span>) := buf(<span class="k">dependent</span>(bt<span class="m">32</span>));
<span class="k">type</span> buf<span class="m">64</span>:<span class="k">Type</span>(<span class="m">0</span>) := buf(<span class="k">dependent</span>(bt<span class="m">64</span>));
<span class="k">function</span> buf_len #[bt:<span class="k">Dependent</span>(buf_typ)](b:buf(bt)):<span class="k">int</span> <span class="k">extern</span>;
</pre></div>
</div>
<p>If an expression <code class="docutils literal notranslate"><span class="pre">xe</span></code> has type <code class="docutils literal notranslate"><span class="pre">xt</span></code>, then the type <code class="docutils literal notranslate"><span class="pre">dependent(xe)</span></code> has kind <code class="docutils literal notranslate"><span class="pre">Dependent(xt)</span></code>.
In the example above, this allows
type <code class="docutils literal notranslate"><span class="pre">buf</span></code> to take a value <code class="docutils literal notranslate"><span class="pre">bt</span></code> as a type parameter
and allows <code class="docutils literal notranslate"><span class="pre">buf_len</span></code> to be polymorphic over values <code class="docutils literal notranslate"><span class="pre">bt</span></code> of type <code class="docutils literal notranslate"><span class="pre">buf_typ</span></code>,
as in a dependent type system.
(From Vale’s perspective, <code class="docutils literal notranslate"><span class="pre">bt</span></code> is promoted to a type in order to use ordinary polymorphism over types.)
However, <code class="docutils literal notranslate"><span class="pre">xe</span></code> must be a global constant and <code class="docutils literal notranslate"><span class="pre">xt</span></code> must be simple named type,
so this is only useful in limited situations.</p>
</div>
<div class="section" id="operands-and-operand-types">
<h2>Operands and operand types<a class="headerlink" href="#operands-and-operand-types" title="Permalink to this headline">¶</a></h2>
<p>Vale expressions have types, while procedure operands have <em>operand types</em>.
Operand types describe both the type of the value carried by the operand (e.g. an integer)
and the location of the operand.
Locations may be global variables (typically registers), constants,
or dynamically constructed locations (typically memory addresses).
Here is an example of operand type declarations for x64 assembly language:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> nat<span class="m">64</span>:<span class="k">Type</span>(<span class="m">0</span>) := <span class="k">int_range</span>(<span class="m">0</span>, <span class="m">0xffff_ffff_ffff_ffff</span>);

<span class="k">operand_type</span> reg<span class="m">64</span>:nat<span class="m">64</span> :=
| <span class="k">inout</span> rax | <span class="k">inout</span> rbx | <span class="k">inout</span> rcx | <span class="k">inout</span> rdx
| <span class="k">inout</span> rsi | <span class="k">inout</span> rdi | <span class="k">inout</span> rbp | <span class="k">inout</span> r<span class="m">8</span>
| <span class="k">inout</span> r<span class="m">9</span> | <span class="k">inout</span> r<span class="m">10</span> | <span class="k">inout</span> r<span class="m">11</span> | <span class="k">inout</span> r<span class="m">12</span>
| <span class="k">inout</span> r<span class="m">13</span> | <span class="k">inout</span> r<span class="m">14</span> | <span class="k">inout</span> r<span class="m">15</span>
;

<span class="k">operand_type</span> shift_amt<span class="m">64</span>:nat<span class="m">64</span> := <span class="k">in</span> rcx | <span class="k">const</span>;
<span class="k">operand_type</span> Mem<span class="m">64</span>(<span class="k">in</span> base:reg<span class="m">64</span>, <span class="k">inline</span> offset:<span class="k">int</span>):nat<span class="m">64</span>;
<span class="k">operand_type</span> dst_opr<span class="m">64</span>:nat<span class="m">64</span> := reg<span class="m">64</span> | Mem<span class="m">64</span>;
<span class="k">operand_type</span> opr<span class="m">64</span>:nat<span class="m">64</span> := dst_opr<span class="m">64</span> | <span class="k">const</span>;
</pre></div>
</div>
<p>This declares a series of operand types:</p>
<ul class="simple">
<li><p>operand type <code class="docutils literal notranslate"><span class="pre">reg64</span></code>, for 64-bit values (of type <code class="docutils literal notranslate"><span class="pre">nat64</span></code>) located in registers <code class="docutils literal notranslate"><span class="pre">rax</span></code> … <code class="docutils literal notranslate"><span class="pre">r15</span></code>,
usable as both input and output operands.</p></li>
<li><p>operand type <code class="docutils literal notranslate"><span class="pre">shift_amt64</span></code>, for x64 shift instructions that require the shift amount
in either register <code class="docutils literal notranslate"><span class="pre">rcx</span></code> or as a constant.</p></li>
<li><p>operand type <code class="docutils literal notranslate"><span class="pre">Mem64</span></code>, for 64-bit values located in memory.</p></li>
<li><p>operand type <code class="docutils literal notranslate"><span class="pre">dst_opr64</span></code>, for operands that can be either a register or memory operand</p></li>
<li><p>operand type <code class="docutils literal notranslate"><span class="pre">opr64</span></code>, for operands that can be either a register, memory operand, or constant.
(Note that <code class="docutils literal notranslate"><span class="pre">const</span></code> is a built-in Vale keyword, not an operand type.)</p></li>
</ul>
<p>For example, an x64 shift-left instruction can be declared to take
a destination operand of operand type <code class="docutils literal notranslate"><span class="pre">dst_opr64</span></code> and a source operand
of type <code class="docutils literal notranslate"><span class="pre">shift_amt64</span></code>:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span> Shl<span class="m">64</span>(<span class="k">inout</span> dst:dst_opr<span class="m">64</span>, <span class="k">in</span> amt:shift_amt<span class="m">64</span>)
</pre></div>
</div>
<div class="section" id="operand-constructors-and-memory">
<h3>Operand constructors and memory<a class="headerlink" href="#operand-constructors-and-memory" title="Permalink to this headline">¶</a></h3>
<p>Locations can be constructed dynamically with <em>operand constructors</em> like <code class="docutils literal notranslate"><span class="pre">Mem64</span></code>.
Such constructors can take other operands as arguments:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span>Shl<span class="m">64</span>(Mem<span class="m">64</span>(rax, <span class="m">60</span>), <span class="m">16</span>);
</pre></div>
</div>
<p>Each operand constructor requires <em>operand procedures</em> for reading and/or writing the location
specified by the operand constructor.
The operand procedures have the name of the operand constructor concatenated
with the suffix “_in” or “_out”:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">var</span> mem:map(<span class="k">int</span>, byte) {:state mem()};

<span class="k">procedure</span> Mem<span class="m">64_</span><span class="k">in</span>(<span class="k">in</span> base:reg_opr<span class="m">64</span>, <span class="k">inline</span> offset:<span class="k">int</span>) <span class="k">returns</span>(o:operand)
    {:operand}
    <span class="k">reads</span>
        mem;
    <span class="k">extern</span>;

<span class="k">procedure</span> Mem<span class="m">64_</span><span class="k">out</span>(<span class="k">in</span> base:reg_opr<span class="m">64</span>, <span class="k">inline</span> offset:<span class="k">int</span>, <span class="k">in</span> o:operand)
    {:operand}
    <span class="k">modifies</span>
        mem;
    <span class="k">extern</span>;
</pre></div>
</div>
<p>In the first procedure, the operand <code class="docutils literal notranslate"><span class="pre">o</span></code> contains the value loaded from memory.
In the second procedure, the operand <code class="docutils literal notranslate"><span class="pre">o</span></code> contains the value being stored to memory.
Operand procedures can optionally have <code class="docutils literal notranslate"><span class="pre">requires</span></code> and <code class="docutils literal notranslate"><span class="pre">ensures</span></code> to specify
properties of <code class="docutils literal notranslate"><span class="pre">o</span></code> and of the other parameters to the procedures.
Operand procedures can also read and write global variables like <code class="docutils literal notranslate"><span class="pre">mem</span></code>.</p>
</div>
<div class="section" id="operand-values-and-locations">
<span id="locations"></span><h3>Operand values and locations<a class="headerlink" href="#operand-values-and-locations" title="Permalink to this headline">¶</a></h3>
<p>Vale procedures can refer to both the value and location of an operand.
For an operand parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>, the expression <code class="docutils literal notranslate"><span class="pre">x</span></code> contains the operand’s value,
while the expression <code class="docutils literal notranslate"><span class="pre">&#64;x</span></code> contains the operand’s location.
This can be used, for example, to require two operands to be in distinct registers:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span> IncrTwo(<span class="k">inout</span> dst<span class="m">1</span>:reg<span class="m">64</span>, <span class="k">inout</span> dst<span class="m">2</span>:reg<span class="m">64</span>)
    <span class="k">requires</span>
        dst<span class="m">1</span> &lt; <span class="m">100</span>;
        dst<span class="m">2</span> &lt; <span class="m">100</span>;
        @dst<span class="m">1</span> != @dst<span class="m">2</span>;
    <span class="k">ensures</span>
        dst<span class="m">1</span> == <span class="k">old</span>(dst<span class="m">1</span>) + <span class="m">1</span>;
        dst<span class="m">2</span> == <span class="k">old</span>(dst<span class="m">2</span>) + <span class="m">1</span>;
{
    Add(dst<span class="m">1</span>, <span class="m">1</span>);
    Add(dst<span class="m">2</span>, <span class="m">1</span>);
}
</pre></div>
</div>
<p>To use <code class="docutils literal notranslate"><span class="pre">&#64;x</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>’s operand type must declare a type for locations, using the <code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">t</span></code> syntax.
The following declaration, for example, tells Vale that the expressions <code class="docutils literal notranslate"><span class="pre">&#64;dst1</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;dst2</span></code>
should have type <code class="docutils literal notranslate"><span class="pre">operandImpl</span></code>:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">operand_type</span> reg<span class="m">64</span>:nat<span class="m">64</span> @ operandImpl :=
| <span class="k">inout</span> rax | <span class="k">inout</span> rbx | <span class="k">inout</span> rcx | <span class="k">inout</span> rdx
...
</pre></div>
</div>
</div>
</div>
<div class="section" id="functions-and-consts">
<span id="functions"></span><h2>Functions and consts<a class="headerlink" href="#functions-and-consts" title="Permalink to this headline">¶</a></h2>
<p>Vale can import functions and constants from the verification framework
using <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">extern</span></code> and <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">x</span> <span class="pre">...</span> <span class="pre">extern</span></code> declarations:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> seven:<span class="k">int</span> <span class="k">extern</span>;

<span class="k">function</span> sum<span class="m">3</span>(x:<span class="k">int</span>, y:<span class="k">int</span>, z:<span class="k">int</span>):<span class="k">int</span> <span class="k">extern</span>;

<span class="k">function</span> sqr(x:<span class="k">int</span>):(z:<span class="k">int</span>)
    <span class="k">ensures</span>
        z &gt;= <span class="m">0</span>;
    <span class="k">extern</span>;

<span class="k">function</span> id#[a:<span class="k">Type</span>(<span class="m">0</span>)](x:a):a <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> test_functions()
{
    <span class="k">assert</span> seven == <span class="m">7</span>;

    <span class="k">assert</span> sum<span class="m">3</span>(<span class="m">10</span>, <span class="m">20</span>, <span class="m">30</span>) == <span class="m">60</span>;
    <span class="k">assert</span> sqr(<span class="m">10</span>) == <span class="m">100</span>;
    <span class="k">assert</span> id(<span class="m">10</span>) == <span class="m">10</span>;
    <span class="k">assert</span> id#[<span class="k">int</span>](<span class="m">10</span>) == <span class="m">10</span>;

    <span class="k">let</span> f:<span class="k">fun</span>(<span class="k">int</span>, <span class="k">int</span>, <span class="k">int</span>) -&gt; <span class="k">int</span> := sum<span class="m">3</span>;
    <span class="k">assert</span> f(<span class="m">10</span>, <span class="m">20</span>, <span class="m">30</span>) == <span class="m">60</span>;

    <span class="k">let</span> g:<span class="k">fun</span>(<span class="k">int</span>) -&gt; <span class="k">int</span> := id;
    <span class="k">assert</span> g(<span class="m">10</span>) == <span class="m">10</span>;
}
</pre></div>
</div>
<p>Polymorphic functions like <code class="docutils literal notranslate"><span class="pre">id</span></code> can be applied to type arguments using <code class="docutils literal notranslate"><span class="pre">#[...]</span></code>;
otherwise, Vale will try to infer the type arguments.
Monomorphic functions have function types <code class="docutils literal notranslate"><span class="pre">fun(...)</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code>;
polymorphic functions can be coerced to monomorphic function types,
as with <code class="docutils literal notranslate"><span class="pre">g</span></code> in the example above.</p>
<p>Dafny and FStar can declare <em>opaque</em> functions whose definitions are hidden from the verifier
unless explicitly revealed.
Vale can reveal an opaque function’s definition with <code class="docutils literal notranslate"><span class="pre">reveal</span> <span class="pre">f</span></code>:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> opaque_sum(x:<span class="k">int</span>, y:<span class="k">int</span>):<span class="k">int</span> <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> test_opaque()
{
    <span class="k">reveal</span> opaque_sum;
    <span class="k">assert</span> opaque_sum(<span class="m">10</span>, <span class="m">20</span>) == <span class="m">30</span>;
}
</pre></div>
</div>
<div class="section" id="custom-operators">
<span id="custom"></span><h3>Custom operators<a class="headerlink" href="#custom-operators" title="Permalink to this headline">¶</a></h3>
<p>Vale programs can abbreviate one-argument and two-argument functions as custom unary and binary operators.
Such operators are not overloaded — there can only be one function for each operator name —
but Vale programs can create as many operator names as desired.</p>
<p>The <a class="reference internal" href="grammar.html#lexical"><span class="std std-ref">Lexical structure</span></a> section describes how to use the <code class="docutils literal notranslate"><span class="pre">#token</span></code> directive to create new operator names (operator tokens).
After creating a name, the Vale code declares a function abbreviation using the
<code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">operator(...)</span> <span class="pre">...</span> <span class="pre">:=</span> <span class="pre">...</span></code> syntax:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span>#token #+# precedence +
#token +. precedence +
#token *. precedence *
#token %. precedence *
#token ~~ precedence !
<span class="k">function</span> <span class="k">operator</span>(#+#) (a:<span class="k">int</span>, b:<span class="k">int</span>):<span class="k">int</span> := opaque_sum;
<span class="k">function</span> <span class="k">operator</span>(+.) (a:poly, b:poly):poly := poly_add;
<span class="k">function</span> <span class="k">operator</span>(*.) (a:poly, b:poly):poly := poly_mul;
<span class="k">function</span> <span class="k">operator</span>(%.) (a:poly, b:poly):poly := poly_mod;
<span class="k">function</span> <span class="k">operator</span>(~~) (a:quad<span class="m">32</span>):poly := quad<span class="m">32_</span>to_poly;

<span class="k">ghost</span> <span class="k">procedure</span> test_opaque()
{
    <span class="k">reveal</span> opaque_sum;
    <span class="k">assert</span> <span class="m">10</span> #+# <span class="m">20</span> == <span class="m">30</span>;
}
</pre></div>
</div>
</div>
<div class="section" id="overloaded-operators">
<span id="overloaded"></span><h3>Overloaded operators<a class="headerlink" href="#overloaded-operators" title="Permalink to this headline">¶</a></h3>
<p>Vale supports a small set of overloadable operators:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.fieldname</span></code> for reading a field of a datatype</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.fieldname</span> <span class="pre">:=</span></code> for updating a field of a datatype with some value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[]</span></code> for reading an item in a collection based on some key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">:=</span> <span class="pre">]</span></code> for updating an item in a collection based on some key and value</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">?[]</span></code> for testing whether a collection contains a key</p></li>
</ul>
<p>Each of these operators can have many implementations.
Each implementation is declared to Vale with a <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">operator(...)</span> <span class="pre">...</span> <span class="pre">extern</span></code> declaration:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">type</span> int_pair:<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">function</span> Mkint_pair(fst:<span class="k">int</span>, snd:<span class="k">int</span>):int_pair <span class="k">extern</span>;

<span class="k">function</span> <span class="k">operator</span>(.fst) (p:int_pair):<span class="k">int</span> <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>(.snd) (p:int_pair):<span class="k">int</span> <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>(.fst :=) (p:int_pair, v:<span class="k">int</span>):int_pair <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>(.snd :=) (p:int_pair, v:<span class="k">int</span>):int_pair <span class="k">extern</span>;

<span class="k">type</span> seq(a:<span class="k">Type</span>(<span class="m">0</span>)):<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;
<span class="k">type</span> map(a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)):<span class="k">Type</span>(<span class="m">0</span>) <span class="k">extern</span>;

<span class="k">function</span> length#[a:<span class="k">Type</span>(<span class="m">0</span>)](s:seq(a)):nat <span class="k">extern</span>;

<span class="k">function</span> <span class="k">operator</span>([])     #[a:<span class="k">Type</span>(<span class="m">0</span>)](s:seq(a), i:<span class="k">int</span>):a <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>([ := ]) #[a:<span class="k">Type</span>(<span class="m">0</span>)](s:seq(a), i:<span class="k">int</span>, v:a):seq(a) <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>([])     #[a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)](m:map(a, b), key:a):b <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>([ := ]) #[a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)](m:map(a, b), key:a, v:b):map(a, b) <span class="k">extern</span>;
<span class="k">function</span> <span class="k">operator</span>(?[])    #[a:<span class="k">Type</span>(<span class="m">0</span>), b:<span class="k">Type</span>(<span class="m">0</span>)](m:map(a, b), key:a):<span class="k">bool</span> <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> test_overload(<span class="k">ghost</span> s:seq(nat), <span class="k">ghost</span> m:map(<span class="k">int</span>, nat))
    <span class="k">requires</span>
        length(s) &gt; <span class="m">3</span>;
{
    <span class="k">let</span> x := Mkint_pair(<span class="m">10</span>, <span class="m">20</span>);
    <span class="k">assert</span> x.fst == <span class="m">10</span>;
    <span class="k">assert</span> x.snd == <span class="m">20</span>;
    <span class="k">let</span> x<span class="m">2</span> := x.(fst := <span class="m">11</span>);
    <span class="k">assert</span> x<span class="m">2</span>.fst == <span class="m">11</span>;
    <span class="k">assert</span> x<span class="m">2</span>.snd == <span class="m">20</span>;

    <span class="k">let</span> s<span class="m">2</span>:seq(nat) := s[<span class="m">3</span> := <span class="m">30</span>];
    <span class="k">assert</span> s<span class="m">2</span>[<span class="m">3</span>] == <span class="m">30</span>;

    <span class="k">assert</span> m?[<span class="m">100</span>] ==&gt; m[<span class="m">100</span>] &gt;= <span class="m">0</span>;
}
</pre></div>
</div>
<p>When an expression like <code class="docutils literal notranslate"><span class="pre">m[100]</span></code> uses an overloaded operator like <code class="docutils literal notranslate"><span class="pre">operator([])</span></code>,
Vale must decide which of the various <code class="docutils literal notranslate"><span class="pre">operator([])</span></code> implementations is appropriate.
To do this, it computes the type <code class="docutils literal notranslate"><span class="pre">t</span></code> of <code class="docutils literal notranslate"><span class="pre">m</span></code>, simplifies <code class="docutils literal notranslate"><span class="pre">t</span></code> until it is an <code class="docutils literal notranslate"><span class="pre">extern</span></code> type
rather than a type abbreviation, and then uses <code class="docutils literal notranslate"><span class="pre">t</span></code>’s name (<code class="docutils literal notranslate"><span class="pre">map</span></code> in this case) for disambiguation.
Thus, there can be one <code class="docutils literal notranslate"><span class="pre">operator([])</span></code> for <code class="docutils literal notranslate"><span class="pre">map</span></code> and one for <code class="docutils literal notranslate"><span class="pre">seq</span></code>,
but not more than one for <code class="docutils literal notranslate"><span class="pre">map</span></code> or more than one for <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p>
</div>
</div>
<div class="section" id="expressions">
<h2>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h2>
<p>See the <a class="reference internal" href="grammar.html#syntax"><span class="std std-ref">Complete Vale syntax</span></a> section for a complete list of Vale expressions.
The following expressions are described in other sections:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;x</span></code> in <a class="reference internal" href="#locations"><span class="std std-ref">Operand values and locations</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">old</span></code> in <a class="reference internal" href="programs.html#procedures"><span class="std std-ref">Procedures</span></a></p></li>
<li><p>function application in <a class="reference internal" href="#functions"><span class="std std-ref">Functions and consts</span></a></p></li>
<li><p>field and subscript operators in <a class="reference internal" href="#overloaded"><span class="std std-ref">Overloaded operators</span></a></p></li>
<li><p>collection and tuple literals in <a class="reference internal" href="#types"><span class="std std-ref">Types</span></a></p></li>
</ul>
<p>Arithmetic operators <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, and <code class="docutils literal notranslate"><span class="pre">-</span></code>
compute new <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">int_range</span></code> values from existing <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">int_range</span></code>
values (see <a class="reference internal" href="#types"><span class="std std-ref">Types</span></a> or
the <a class="reference external" href="https://raw.githubusercontent.com/project-everest/vale/master/doc/types.txt">formal type rules</a>).
Integer comparison operators <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, and <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>
compute <code class="docutils literal notranslate"><span class="pre">bool</span></code> values from <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">int_range</span></code> values.</p>
<p>Comparisons can be chained together: <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span> <span class="pre">&lt;=</span> <span class="pre">d</span></code> is an abbreviation for
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">c</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span> <span class="pre">&lt;=</span> <span class="pre">d</span></code>.</p>
<p>Equality <code class="docutils literal notranslate"><span class="pre">==</span></code> and inequality <code class="docutils literal notranslate"><span class="pre">!=</span></code> compute <code class="docutils literal notranslate"><span class="pre">bool</span></code> values (in Dafny)
or <code class="docutils literal notranslate"><span class="pre">prop</span></code> values (in FStar).</p>
<p><code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">is</span> <span class="pre">C</span></code> tests whether a datatype value <code class="docutils literal notranslate"><span class="pre">e</span></code> is an instance of datatype constructor <code class="docutils literal notranslate"><span class="pre">C</span></code>
(like Dafny’s <code class="docutils literal notranslate"><span class="pre">e.C?</span></code> or FStar’s <code class="docutils literal notranslate"><span class="pre">C?</span> <span class="pre">e</span></code>).</p>
<p>Logical operators <code class="docutils literal notranslate"><span class="pre">!</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, <code class="docutils literal notranslate"><span class="pre">==&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;==</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;==&gt;</span></code>
compute <code class="docutils literal notranslate"><span class="pre">bool</span></code> values from existing <code class="docutils literal notranslate"><span class="pre">bool</span></code> values in Dafny.
For FStar, they work on both <code class="docutils literal notranslate"><span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">prop</span></code> values.</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">e1</span> <span class="pre">then</span> <span class="pre">e2</span> <span class="pre">else</span> <span class="pre">e3</span></code> selects either <code class="docutils literal notranslate"><span class="pre">e2</span></code> or <code class="docutils literal notranslate"><span class="pre">e3</span></code> based on <code class="docutils literal notranslate"><span class="pre">e1</span></code> of type <code class="docutils literal notranslate"><span class="pre">bool</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">e1</span> <span class="pre">in</span> <span class="pre">e2</span></code> introduces a variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, equal to <code class="docutils literal notranslate"><span class="pre">e1</span></code>, in <code class="docutils literal notranslate"><span class="pre">e2</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">fun(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code>, sometimes known as a “lambda”, creates an anonymous function
with parameters <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code> and body <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> computes the current state (i.e. all register values, memory values, etc.),
of type <code class="docutils literal notranslate"><span class="pre">state</span></code>.
The <code class="docutils literal notranslate"><span class="pre">state</span></code> type is not defined by Vale,
but is instead user-defined in the underlying verification framework
(see <code class="docutils literal notranslate"><span class="pre">va_state</span></code> in <a class="reference internal" href="library.html#interface"><span class="std std-ref">Interface with verification framework</span></a>).
Most procedures shouldn’t refer to <code class="docutils literal notranslate"><span class="pre">this</span></code>, but it is occasionally used for
implementing instructions (see <a class="reference internal" href="library.html#instructions"><span class="std std-ref">Instructions</span></a>),
which can read <code class="docutils literal notranslate"><span class="pre">this</span></code> or assign <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">:=</span> <span class="pre">...</span></code>.</p>
<div class="section" id="quantifiers">
<span id="id2"></span><h3>Quantifiers<a class="headerlink" href="#quantifiers" title="Permalink to this headline">¶</a></h3>
<p>Vale supports two <em>quantifiers</em>, <code class="docutils literal notranslate"><span class="pre">forall</span></code> and <code class="docutils literal notranslate"><span class="pre">exists</span></code>.
The expression <code class="docutils literal notranslate"><span class="pre">forall(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code> means that <code class="docutils literal notranslate"><span class="pre">e</span></code>
is true for all values that can be assigned to variables <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code>
of type <code class="docutils literal notranslate"><span class="pre">t1</span></code> … <code class="docutils literal notranslate"><span class="pre">tn</span></code>.
The expression <code class="docutils literal notranslate"><span class="pre">exists(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code> means that <code class="docutils literal notranslate"><span class="pre">e</span></code>
is true for at least one assignment of values to variables <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code>
of type <code class="docutils literal notranslate"><span class="pre">t1</span></code> … <code class="docutils literal notranslate"><span class="pre">tn</span></code>.
In Dafny, <code class="docutils literal notranslate"><span class="pre">forall</span></code> and <code class="docutils literal notranslate"><span class="pre">exists</span></code> expressions have type <code class="docutils literal notranslate"><span class="pre">bool</span></code>.
In FStar, they have type <code class="docutils literal notranslate"><span class="pre">prop</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">forall</span></code> and <code class="docutils literal notranslate"><span class="pre">exists</span></code>, used in combination with
other expressions like arithmetic and function application,
are often difficult for verification frameworks to reason about
completely automatically.
Specifically, it’s hard for the verification framework to answer these two questions:</p>
<ul class="simple">
<li><p>If the verifier knows <code class="docutils literal notranslate"><span class="pre">forall(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code> and wants to use this to
prove some formula <code class="docutils literal notranslate"><span class="pre">Q</span></code>, which values should it instantiate <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code>
with?  For example, if it knows <code class="docutils literal notranslate"><span class="pre">forall(x:int)</span> <span class="pre">p(x</span> <span class="pre">+</span> <span class="pre">x)</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span></code>,
which <code class="docutils literal notranslate"><span class="pre">x</span></code> should it choose to prove <code class="docutils literal notranslate"><span class="pre">p(10)</span> <span class="pre">==</span> <span class="pre">15</span></code>?
(In this example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5</span></code> is a good choice,
but it’s not obvious how a verifier should guess this automatically.)</p></li>
<li><p>If the verifier wants to prove <code class="docutils literal notranslate"><span class="pre">exists(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code>,
which values for <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code> should it choose to prove <code class="docutils literal notranslate"><span class="pre">e</span></code>?
For example, it can prove <code class="docutils literal notranslate"><span class="pre">exists(x:int)</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">10</span></code> with <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">10</span></code>,
but it’s not obvious how to guess this automatically,
especially in more complicated examples.</p></li>
</ul>
<p>Dafny and FStar rely on <code class="docutils literal notranslate"><span class="pre">triggers</span></code> (also called patterns)
to determine how to use <code class="docutils literal notranslate"><span class="pre">forall</span></code> expressions and how to prove <code class="docutils literal notranslate"><span class="pre">exists</span></code>
expressions.
For example, suppose the verifier knows <code class="docutils literal notranslate"><span class="pre">forall(x:int,</span> <span class="pre">y:int)</span> <span class="pre">f(x,</span> <span class="pre">y)</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code>
and wants to prove <code class="docutils literal notranslate"><span class="pre">f(2,</span> <span class="pre">3)</span> <span class="pre">==</span> <span class="pre">5</span></code>.
This can be proven with <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">3</span></code>, which the verifier can guess
by matching the expression <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code> with the expression <code class="docutils literal notranslate"><span class="pre">f(2,</span> <span class="pre">3)</span></code>.
To enable this matching, a Vale program annotates the <code class="docutils literal notranslate"><span class="pre">forall</span></code> expression with the <em>trigger</em>
<code class="docutils literal notranslate"><span class="pre">{f(x,</span> <span class="pre">y)}</span></code>, which tells the verifier to try to find terms of the form <code class="docutils literal notranslate"><span class="pre">f(...,</span> <span class="pre">...)</span></code>
and match them to <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code>:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span>(x:<span class="k">int</span>, y:<span class="k">int</span>){f(x, y)} f(x, y) == x + y
</pre></div>
</div>
<p>A trigger can have more than one expression in it;
the trigger fires if all the expressions in the trigger are matched:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">forall</span>(x:<span class="k">int</span>, y:<span class="k">int</span>){f(x), g(y))} f(x) == g(y)
</pre></div>
</div>
<p>There can also be more than one trigger; the verifier tries to match any of them.</p>
<p>Dafny will automatically infer the triggers shown in the examples above,
so the Vale code can safely omit them.
However, FStar will not infer them, so it’s a good idea to always write the triggers explicitly when using FStar.
(Without the triggers, FStar lets the underlying SMT solver choose the triggers,
and these triggers tend to be dangerously aggressive, leading to slow proofs and timeouts.)</p>
<p>Even when using Dafny, not all quantified expressions have good triggers.
The expression <code class="docutils literal notranslate"><span class="pre">forall(x:int)</span> <span class="pre">p(x</span> <span class="pre">+</span> <span class="pre">x)</span> <span class="pre">==</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span></code>, for example,
cannot be matched with <code class="docutils literal notranslate"><span class="pre">p(10)</span> <span class="pre">==</span> <span class="pre">15</span></code> to produce <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5</span></code> in any obvious way,
since <code class="docutils literal notranslate"><span class="pre">p(10)</span> <span class="pre">==</span> <span class="pre">15</span></code> doesn’t contain <code class="docutils literal notranslate"><span class="pre">5</span></code> anywhere.
Dafny’s automatic inference of triggers doesn’t help, since there is no good trigger to infer.
Therefore, it’s wise to use quantified expressions that have good triggers.
For example, the expression <code class="docutils literal notranslate"><span class="pre">forall(y:int)</span> <span class="pre">y</span> <span class="pre">%</span> <span class="pre">2</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">==&gt;</span> <span class="pre">p(y)</span> <span class="pre">==</span> <span class="pre">y</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">3</span></code> can use <code class="docutils literal notranslate"><span class="pre">{p(y)}</span></code>
as a trigger (and Dafny will infer this trigger automatically).
This is logically equivalent to the earlier expression,
but enables better automation.</p>
<p>There are two other questions relevant to quantifiers (the flip side of the
two earlier questions):</p>
<ul class="simple">
<li><p>How does a verifier prove <code class="docutils literal notranslate"><span class="pre">forall(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code>?</p></li>
<li><p>How does a verifier use <code class="docutils literal notranslate"><span class="pre">exists(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code> to prove some formula <code class="docutils literal notranslate"><span class="pre">Q</span></code>?</p></li>
</ul>
<p>Compared with the two earlier questions, these are relatively easy and do not require triggers.
For example, a verification framework can prove <code class="docutils literal notranslate"><span class="pre">forall(x1:t1,</span> <span class="pre">...,</span> <span class="pre">xn:tn)</span> <span class="pre">e</span></code> simply
by trying to prove <code class="docutils literal notranslate"><span class="pre">e</span></code> with variables <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code> in scope.
There is no need to instantiate <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code> with particular values to do this,
so there is no decision to make on which values to instantiate <code class="docutils literal notranslate"><span class="pre">x1</span></code> … <code class="docutils literal notranslate"><span class="pre">xn</span></code> with.
However, <code class="docutils literal notranslate"><span class="pre">e</span></code> itself could be difficult to prove, and the verification framework
may need hints to complete the proof of <code class="docutils literal notranslate"><span class="pre">e</span></code>, such as calls to lemmas.
Vale programs can use a <code class="docutils literal notranslate"><span class="pre">forall</span></code> statement to supply such hints:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> f<span class="m">1</span>(x:<span class="k">int</span>, y:<span class="k">int</span>):<span class="k">bool</span> <span class="k">extern</span>;
<span class="k">function</span> f<span class="m">2</span>(x:<span class="k">int</span>, y:<span class="k">int</span>):<span class="k">bool</span> <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> lemma_f<span class="m">1_</span>f<span class="m">2</span>(<span class="k">ghost</span> x:<span class="k">int</span>, <span class="k">ghost</span> y:<span class="k">int</span>)
    <span class="k">requires</span>
        f<span class="m">1</span>(x, y);
    <span class="k">ensures</span>
        f<span class="m">2</span>(x, y);
    <span class="k">extern</span>;

<span class="k">ghost</span> <span class="k">procedure</span> test_forall()
    <span class="k">ensures</span>
        <span class="k">forall</span>(x:<span class="k">int</span>, y:<span class="k">int</span>){f<span class="m">1</span>(x, y)}{f<span class="m">2</span>(x, y)} f<span class="m">1</span>(x, y) ==&gt; f<span class="m">2</span>(x, y);
{
    <span class="k">forall</span> (x:<span class="k">int</span>, y:<span class="k">int</span>){f<span class="m">2</span>(x, y)}
        f<span class="m">1</span>(x, y) <span class="k">implies</span> f<span class="m">2</span>(x, y) <span class="k">by</span>
    {
        lemma_f<span class="m">1_</span>f<span class="m">2</span>(x, y);
    }
}
</pre></div>
</div>
<p>In this example, the <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x:int,</span> <span class="pre">y:int)...{...}</span></code> statement proves
<code class="docutils literal notranslate"><span class="pre">forall(x:int,</span> <span class="pre">y:int){f2(x,</span> <span class="pre">y)}</span> <span class="pre">f1(x,</span> <span class="pre">y)</span> <span class="pre">==&gt;</span> <span class="pre">f2(x,</span> <span class="pre">y)</span></code>,
which in turn proves <code class="docutils literal notranslate"><span class="pre">test_forall</span></code>’s postcondition.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">exists</span></code>, a <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">exists</span></code> statement (Dafny-only, not FStar)
can extract variables from an <code class="docutils literal notranslate"><span class="pre">exists</span></code> expression in order to use
those variables to prove other expressions, such as the precondition to
<code class="docutils literal notranslate"><span class="pre">lemma_f1_f2</span></code> in the following example:</p>
<div class="highlight-vale notranslate"><div class="highlight"><pre><span></span><span class="k">ghost</span> <span class="k">procedure</span> test_exists()
    <span class="k">requires</span>
        <span class="k">exists</span>(x:<span class="k">int</span>, y:<span class="k">int</span>){f<span class="m">1</span>(x, y)} f<span class="m">1</span>(x, y);
{
    <span class="c">// Ask verifier to choose some x and y such that f1(x, y):</span>
    <span class="k">let</span> <span class="k">exists</span> (x:<span class="k">int</span>, y:<span class="k">int</span>){f<span class="m">1</span>(x, y)} f<span class="m">1</span>(x, y);
    <span class="c">// Now we have x and y as local ghost variables and we can use them:</span>
    lemma_f<span class="m">1_</span>f<span class="m">2</span>(x, y);
}
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="grammar.html" class="btn btn-neutral float-right" title="Complete Vale syntax" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="programs.html" class="btn btn-neutral float-left" title="Programs and procedures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Chris Hawblitzel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>